<!DOCTYPE html>
<html lang = "en">
  <head>
    <meta charset = "utf-8">
    <title>Ellen Cooper</title>
    <link rel = "stylesheet" href = "styles.css">
    <link rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Nixie+One" rel="stylesheet">
  </head>
  <body>
    <header>
      <h1>
        <a href = "index.html">Ellen Cooper</a>
      </h1>
      <div class = top-nav>
        <nav>
          <a href="index.html">About</a>
          <a href="blog.html">Blog</a>
        </nav>
      </div>
    </header>
    <section class = "main">
      <h2 class = "title">
        Turing, the first Six Weeks: Surprises and Reflections
      </h2><br><br>
      <p>The first 6-week module at the Turing School of Software and Design is focused on Ruby fundamentals, and features increasingly complex projects written in pure Ruby. We started with a small-scale project the first week that involved implementing a simple algorithm to check the validity of a credit card, and finished the module with a two week long pair project that implemented a complex sales analysis application from scratch. Along the way we learned and put in practice fundamental principles of object-oriented programming and test-driven development.</p><br>
      <p>Unexpectedly, my favorite technical concept of the module was TDD and I was surprised by how quickly I embraced the TDD approach. Before Turing I had heard vaguely of testing, and expected it to be something that was necessary to conform with best practices but would feel like a hindrance and a distraction from the actual programming. Once I learned the purpose and strategies of TDD, I realized that it was actually the opposite: testing actually acts as a blueprint for the shape and functionality of your application, and can save the developer significant time and effort during the development process, especially as changes are made to more complex programs. Particularly in the last two projects of the module, which involved many classes and interactions, it is difficult to imagine how one would complete the project efficiently without testing. For example in the final project, my partner and I decided when we were about 80% done to implement a refactor that would require moving a method that appeared in many classes to a module, and renaming an instance variable that was present in many classes. This refactor required small changes in about every file of our application. TDD made this process much more more manageable by allowing us to quickly identify any unforeseen consequences of the change, or any place we had forgotten to modify the code, and make additional changes accordingly. TDD acts as a diagnosis tool for your code, immediately pinpointing any issues and allowing the developer to have confidence that their application is functioning as expected after changes or new features are introduced.</p><br>

      <p>Now, at the end of the module, I feel extremely comfortable with Ruby and TDD and very confident in my ability to solve problems with code. Six weeks was a long time to spend on pure Ruby, but I think having the time to really reinforce the fundamentals and improve the design of our code will pay off as we grow as developers and start using more technologies. Iâ€™m excited to dive into Rails in the next module and start building full web applications.</p>

    </section>
    <footer>
      <div class = bottom-nav>
        <nav>
          <a href="index.html">About</a>
          <a href="blog.html">Blog</a>
          <a href="https://www.linkedin.com/in/ellen-cooper/">LinkedIn</a>
          <a href="https://github.com/emcooper">Github</a>
        </nav>
      </div>
    </header>
  </body>
</html>
